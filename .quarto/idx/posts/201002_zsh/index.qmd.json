{"title":"xterm, zsh, spawn-new-terminal, *BSD","markdown":{"yaml":{"title":"xterm, zsh, spawn-new-terminal, *BSD","author":"Jona JOACHIM","date":"2010-02-10","categories":["unix"]},"containsRefs":false,"markdown":"\n\nxterm defines a very convenient action called spawn-new-terminal().\nUsing that action you can duplicate your current terminal and obtain a\nshell in your current working directory even if you're inside a program\nlike vim or mutt.\n\nFrom the man page:\n\n       spawn-new-terminal(params)\n               Spawn  a  new xterm process.  This is available on\n               systems which have a modern version of the process\n               filesystem, e.g., \"/proc\", which xterm can read.\n\n               Use the \"cwd\" process entry, e.g., /proc/12345/cwd\n               to obtain the working  directory  of  the  process\n               which is running in the current xterm.\n\nYou can bind this action to a key using Xresources. For example I bind\nthe action to Alt-n. Here's the relevant part from my .Xdefaults:\n\n```default\nxterm*VT100.translations: #override \\n\\\n        Meta <Key>n:spawn-new-terminal()\n```\n\nThe problem is that on *BSD you don't have a procfs, at least not one\nthat looks like the one on Linux.\n\nSo to actually get this working, xterm needs another way to find out the\ncurrent working directory (CWD) of the shell that runs inside of it. I\nfound out that this is not so easy and after some tinkering I decided to\ngo for a dirty hack. The idea is, if I can't find out the cwd of a zsh process\non my own then perhaps I can ask zsh gently to tell it.\n\nZsh, like any other shell, lets you define functions, however certain\nfunctions have a special meaning for zsh: they define hooks.\nWe use 2 hooks here: chpwd(), called whenever the CWD of zsh changes,\nand zshexit(), called when the shell quits.\n\nHere are the relevant parts from my .zshrc:\n\n```bash\nfunction chpwd()\n{\n    echo -n ${PWD} > ${HOME}/.zsh/${PPID}.pwd\n}\n#call chpwd once on startup\nchpwd\n\nfunction zshexit()\n{\n    rm ${HOME}/.zsh/${PPID}.pwd\n}\n```\n\nNow for the xterm part. The relevant function is HandleSpawnTerminal()\nin misc.c. Here's my modified version:\n\n```C\n#include <sys/types.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <limits.h>\n#include <err.h>\n\n/* ARGSUSED */\nvoid\nHandleSpawnTerminal(Widget w GCC_UNUSED,\n\t\t    XEvent * event GCC_UNUSED,\n\t\t    String * params,\n\t\t    Cardinal *nparams)\n{\n    static char zshdir[] = \".zsh\";\n    static char termpath[] = \"xterm\";\n\n    pid_t pid, forkpid;\n    uid_t uid;\n    struct passwd *passwd;\n\n    char pathname[_POSIX_PATH_MAX];\n    char zshcwd[_POSIX_PATH_MAX];\n\n    char *home;\n    FILE *fp;\n\n    pid = getpid();\n\n    uid = geteuid();\n    passwd = getpwuid(uid);\n    home = passwd->pw_dir;\n\n    snprintf(pathname, sizeof pathname, \"%s/%s/%ld.pwd\", home, zshdir, (long)pid);\n\n    fp = fopen(pathname, \"r\");\n    if(fp == NULL)\n    {\n        warn(\"couldn't open %s\", pathname);\n        return;\n    }\n    if(fgets(zshcwd, sizeof zshcwd, fp) == NULL)\n    {\n        warn(\"couldn't read from %s\", pathname);\n        fclose(fp);\n        return;\n    }\n\n    fclose(fp);\n\n    /* The reaper will take care of cleaning up the child */\n    forkpid = fork();\n    if(forkpid < 0)\n    {\n        warn(\"Could not fork\");\n        return;\n    }\n    if(forkpid == 0)\n    {\n        /* We are the child */\n        if(chdir(zshcwd) < 0)\n            err(1, \"could not chdir to %s\", zshcwd);\n\n        unsigned myargc = *nparams + 1;\n        char **myargv = TypeMallocN(char *, myargc + 1);\n        unsigned n = 0;\n\n        myargv[n++] = termpath;\n\n        while (n < myargc) {\n            myargv[n++] = *params++;\n        }\n\n        myargv[n] = 0;\n        execvp(termpath, myargv);\n\n        /* If we get here, we've failed */\n        err(1, \"exec of '%s'\", termpath);\n    } else {\n        /* We are the parent\n         * we just live our life */\n    }\n}\n```\n\nNow you just have to reconfigure xterm with --enable-exec-xterm and\nbuild it.","srcMarkdownNoYaml":"\n\nxterm defines a very convenient action called spawn-new-terminal().\nUsing that action you can duplicate your current terminal and obtain a\nshell in your current working directory even if you're inside a program\nlike vim or mutt.\n\nFrom the man page:\n\n       spawn-new-terminal(params)\n               Spawn  a  new xterm process.  This is available on\n               systems which have a modern version of the process\n               filesystem, e.g., \"/proc\", which xterm can read.\n\n               Use the \"cwd\" process entry, e.g., /proc/12345/cwd\n               to obtain the working  directory  of  the  process\n               which is running in the current xterm.\n\nYou can bind this action to a key using Xresources. For example I bind\nthe action to Alt-n. Here's the relevant part from my .Xdefaults:\n\n```default\nxterm*VT100.translations: #override \\n\\\n        Meta <Key>n:spawn-new-terminal()\n```\n\nThe problem is that on *BSD you don't have a procfs, at least not one\nthat looks like the one on Linux.\n\nSo to actually get this working, xterm needs another way to find out the\ncurrent working directory (CWD) of the shell that runs inside of it. I\nfound out that this is not so easy and after some tinkering I decided to\ngo for a dirty hack. The idea is, if I can't find out the cwd of a zsh process\non my own then perhaps I can ask zsh gently to tell it.\n\nZsh, like any other shell, lets you define functions, however certain\nfunctions have a special meaning for zsh: they define hooks.\nWe use 2 hooks here: chpwd(), called whenever the CWD of zsh changes,\nand zshexit(), called when the shell quits.\n\nHere are the relevant parts from my .zshrc:\n\n```bash\nfunction chpwd()\n{\n    echo -n ${PWD} > ${HOME}/.zsh/${PPID}.pwd\n}\n#call chpwd once on startup\nchpwd\n\nfunction zshexit()\n{\n    rm ${HOME}/.zsh/${PPID}.pwd\n}\n```\n\nNow for the xterm part. The relevant function is HandleSpawnTerminal()\nin misc.c. Here's my modified version:\n\n```C\n#include <sys/types.h>\n#include <pwd.h>\n#include <unistd.h>\n#include <limits.h>\n#include <err.h>\n\n/* ARGSUSED */\nvoid\nHandleSpawnTerminal(Widget w GCC_UNUSED,\n\t\t    XEvent * event GCC_UNUSED,\n\t\t    String * params,\n\t\t    Cardinal *nparams)\n{\n    static char zshdir[] = \".zsh\";\n    static char termpath[] = \"xterm\";\n\n    pid_t pid, forkpid;\n    uid_t uid;\n    struct passwd *passwd;\n\n    char pathname[_POSIX_PATH_MAX];\n    char zshcwd[_POSIX_PATH_MAX];\n\n    char *home;\n    FILE *fp;\n\n    pid = getpid();\n\n    uid = geteuid();\n    passwd = getpwuid(uid);\n    home = passwd->pw_dir;\n\n    snprintf(pathname, sizeof pathname, \"%s/%s/%ld.pwd\", home, zshdir, (long)pid);\n\n    fp = fopen(pathname, \"r\");\n    if(fp == NULL)\n    {\n        warn(\"couldn't open %s\", pathname);\n        return;\n    }\n    if(fgets(zshcwd, sizeof zshcwd, fp) == NULL)\n    {\n        warn(\"couldn't read from %s\", pathname);\n        fclose(fp);\n        return;\n    }\n\n    fclose(fp);\n\n    /* The reaper will take care of cleaning up the child */\n    forkpid = fork();\n    if(forkpid < 0)\n    {\n        warn(\"Could not fork\");\n        return;\n    }\n    if(forkpid == 0)\n    {\n        /* We are the child */\n        if(chdir(zshcwd) < 0)\n            err(1, \"could not chdir to %s\", zshcwd);\n\n        unsigned myargc = *nparams + 1;\n        char **myargv = TypeMallocN(char *, myargc + 1);\n        unsigned n = 0;\n\n        myargv[n++] = termpath;\n\n        while (n < myargc) {\n            myargv[n++] = *params++;\n        }\n\n        myargv[n] = 0;\n        execvp(termpath, myargv);\n\n        /* If we get here, we've failed */\n        err(1, \"exec of '%s'\", termpath);\n    } else {\n        /* We are the parent\n         * we just live our life */\n    }\n}\n```\n\nNow you just have to reconfigure xterm with --enable-exec-xterm and\nbuild it."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":{"light":"flatly","dark":"slate"},"title-block-banner":true,"title":"xterm, zsh, spawn-new-terminal, *BSD","author":"Jona JOACHIM","date":"2010-02-10","categories":["unix"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}