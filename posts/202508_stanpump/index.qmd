---
title: Deep dive into STANPUMP
author: "Jona JOACHIM"
date: "2025-08-19"
categories: [pharmacometrics, tci]
image: "Screenshot_20250819_135400.png"
bibliography: references.bib
csl: british-journal-of-anaesthesia.csl
---

## Pharmacometrics, TCI and STANPUMP
Target controlled infusion (TCI) is a technique where the infusion of drugs is controlled in real time by algorithms to achieve quickly and safely, without overshoot, the desired concentration of drug in a patients blood and / or at the effect site of the drug. This technique, while not limited to anesthesia, has seen wide application only in the perioperative setting where anesthesia related drugs are infused to obtain a stable sedation when total intravenous anesthesia (TIVA) is used.

TCI is based on pharmacometric models called PKPD models for pharmacokinetic-pharmacodynamic models. These models describe the drug distribution and metabolism through the body (pharmacokinetics) and the effect of the drug on the body (pharmacodynamics). Most of the time, the effect will be the level of sedation but this is not mandatory. From the first uses of TCI in the 1980s @struys_history_2016 to today, a lot of effort has gone into the development of new PKPD models. These models are now available for nearly every drug used for anesthesia. A lot of literature is available on PKPD models and model design and a lot of software is available to build and fit these models. The best known software is NONMEM but numerous others are available, even open source software such as nlmixr2 @nlmixr.

Most PKPD models for anesthesia are compartmental models with 3 compartments. A1 is typically the amount of drug in the plasma.
Additionally, Ce is the concentration in the "effect compartment" which drives the drug effect.

However, in order to use new models, these models need to be integrated in the TCI systems.

Currently, there are few TCI systems available. Most are proprietary and closed source. Additionally, the algorithms used for TCI, which needs to inverse PKPD models, are less well known. The only open source TCI system I'm aware of is [STANPUMP](https://opentci.org/code/stanpump) from the 1990s.

In this blog post, I will take a deep dive into the STANPUMP source code to try and understand the algorithms involved and see if I can implement them in a modern fashion. The aim is to understand the algorithms and have a minimal open source implementation from which to work.

## Mathematics

PKPD models can be described by a set of ordinary differential equations (ODE) with one equation per compartment.
In anesthesia, most drugs follow a 3-compartment model with can be mathematically described as follows:

![](Screenshot_20250819_135400.png)

$$
\begin{equation}
\begin{aligned}
\frac{dA_1}{dt} & = A_2 k_{21} + A_3 k_{31} - A_1(k_{10} + k_{12} + k_{13}) + \text{Infusion} \\
\frac{dA_2}{dt} & = A_1 k_{12} - A_2 k_{21} \\
\frac{dA_3}{dt} & = A_1 k_{13} - A_3 k_{31} \\
\frac{dC_e}{dt} & = k_{e0}\left(\frac{A_1}{V_c} - C_e\right)
\end{aligned}
\end{equation}
$$ {#eq-ode}

$A_n$ is the amount of drug in compartment $n$, $k_ij$ is the rate constant which describes the speed with which the drug moves from compartement $i$ to compartment $j$. This is not Fick's laws of diffusion because diffusion is driven by concentration, not by drug amount. It took me some time to understand that we are talking about the drug amount, not the concentration. This was difficult to understand especially since there is an exception for the effect site compartment $Ce$ where the rate constant $k_e0$ drives directly concentration. Once, the effect site compartment was treated as a regular compartment (with $k_14$ and $k_41$ rate constants). However, nowadays it is treated as a special compartment with zero volume and a single rate constant $k_e0$ (= $k_41$) and $k_14$ is zero. Since the volume is zero, no drug actually moves to the compartment and it is driven by concentration.

If we leave aside the infusion term for one moment, we can write the equations in matrix form as

$\frac{dA}{dt} = S \cdot A^T$

Where $A$ is the vector \begin{pmatrix} A_1 & A_2 & A_3 \end{pmatrix} and S is the system matrix.

$$
\mathbf{S} = \begin{pmatrix}
-(k_{10} + k_{12} + k_{13}) & k_{21} & k_{31} \\
k_{12} & -k_{21} & 0 \\
k_{13} & 0 & -k_{31}
\end{pmatrix}
$$

This expression can be integrated to obtain the following closed form expression:

$$
Cc(t) = A_1 e^{-\lambda_1 t} + A_2 e^{-\lambda_2 t} + A_3 e^{-\lambda_3 t}
$$ {#eq-exponential}

or simply $Cc = \sum_n A_n e^{-\lambda_n t}$

For this, we need to calculate the exponential decay constants $\lambda$, which are the eigenvalues for the system.

However, this equation does not account for infusion, it describes the clearance from plasma starting from an initial value $A$.

If we want to solve the ODE system while taking into account the infusion term $J$, the equation becomes more complicated @shafer_algorithms_1992,@bailey_simple_1991. This equation introduces coefficients $c^p$ which are outlined below.

$Cc = \sum_{n} A_n e^{-\lambda_n dt} + c^p_n J (1 - e^{-\lambda_n dt})$

The equation can also be obtained for the effect site concentration:

$Ce = \sum_{n} A_n e^{-\lambda_n dt} + c^e_n J (1 - e^{-\lambda_n dt})$

In this case, the vector A contains a fourth term for the effect compartment, $k_e0$ is added as a fourth term to $\lambda$ and different coefficients $c_e$ are used.

These formulas are valid for constant infusion rate $J$. If the infusion rate is changed, the solution can be calculated up to the last value during the previous infusion rate and this solution can be used as an initial state $A$ in the new formula with new rate constant.

### Pharmacokinetic Coefficient

This is the most frustrating part for me. I copied these coefficients from STANPUMP but I don't know how to derive them mathematically. Apparently, deriving them involves applying the Laplace transform to @eq-ode, do some operations in the Laplace domain, simplify the expression using partial fraction decomposition and apply the inverse Laplace transform. However these maths are beyond what I understand. I would be thrilled if somebody could explain to me how the coefficients are derived.

#### Three Compartment Model

$$
\begin{equation}
\begin{aligned}
c^p_1 & = \frac{(k_{21} - \lambda_1)(k_{31} - \lambda_1)}{(\lambda_1 - \lambda_2)(\lambda_1 - \lambda_3) \cdot V_c \cdot \lambda_1}
\\
c^p_2 & = \frac{(k_{21} - \lambda_2)(k_{31} - \lambda_2)}{(\lambda_2 - \lambda_1)(\lambda_2 - \lambda_3) \cdot V_c \cdot \lambda_2}
\\
c^p_3 & = \frac{(k_{21} - \lambda_3)(k_{31} - \lambda_3)}{(\lambda_3 - \lambda_2)(\lambda_3 - \lambda_1) \cdot V_c \cdot \lambda_3}
\\
c^e_1 & = c^p_1 \cdot \frac{k_{e0}}{k_{e0} - \lambda_1}
\\
c^e_2 & = c^p_2 \cdot \frac{k_{e0}}{k_{e0} - \lambda_2}
\\
c^e_3 & = c^p_3 \cdot \frac{k_{e0}}{k_{e0} - \lambda_3}
\\
c^e_4 & = \frac{(k_{e0} - k_{21})(k_{e0} - k_{31})}{(\lambda_1 - k_{e0})(\lambda_2 - k_{e0})(\lambda_3 - k_{e0}) \cdot V_c}
\end{aligned}
\end{equation}
$$

### Two Compartment Model

$$
\begin{equation}
\begin{aligned}
c^p_1 & = \frac{k_{21} - \lambda_1}{(\lambda_2 - \lambda_1) \cdot V_c \cdot \lambda_1}
\\
c^p_2 & = \frac{k_{21} - \lambda_2}{(\lambda_1 - \lambda_2) \cdot V_c \cdot \lambda_2}
\\
c^e_1 & = c^p_1 \cdot \frac{k_{e0}}{k_{e0} - \lambda_1}
\\
c^e_2 & = c^p_2 \cdot \frac{k_{e0}}{k_{e0} - \lambda_2}
\\
c^e_3 & = \frac{k_{21} - k_{e0}}{(\lambda_1 - k_{e0})(\lambda_2 - k_{e0}) \cdot V_c}
\end{aligned}
\end{equation}
$$

### One Compartment Model

$$
\begin{equation}
\begin{aligned}
c_{p1} & = \frac{1}{\lambda_1 \cdot V_c}
\\
e_{p1} & = c_{p1} \cdot \frac{k_{e0}}{k_{e0} - \lambda_1}
\\
e_{p1} & = \frac{1}{(\lambda_1 - k_{e0}) \cdot V_c}
\end{aligned}
\end{equation}
$$

## Source code
The original source code for STANPUMP was written by Steven L. Shafer, one of the fathers of TCI. Steven Shafer wanted this software to be open source from the beginning which is a real gift for the community. Later, Charles Minto created the Open TCI website, which collects models and software related to PKPD and TCI. The latest version of STANPUMP is available here: [https://opentci.org/code/stanpump](https://opentci.org/code/stanpump).

### 16-bit real mode MSDOS
STANPUMP was written for the MSDOS operating system, running on x86 systems in "real mode". In real mode, program address physical memory directly with a maximum of 1 MB adressable memory. There is no memory protection and any memory location can be read and written by any program. The program interacts directly with the hardware through interrupts. This can for example be seen in the STANPUMP code which interacts with the keyboard or renders text on the screen.

```C
#define INT09	0x0009	    /* Keyboard interrupt number	       */
#define INT1B	0x001B	    /* Ctrl-C interrupt number		       */
#define INT23	0x0023	    /* Ctrl-Break interrupt number	       */

void set_keyboard()
	{
       OldInt09 = _dos_getvect( INT09 );
       OldInt1B = _dos_getvect( INT1B );
       OldInt23 = _dos_getvect( INT23 );

       KbdPtr = Int09;
       _dos_setvect( INT09, KbdPtr );

       BrkPtr = Int1B;
       _dos_setvect( INT1B, BrkPtr);

       BrkPtr = Int23;
       _dos_setvect( INT23, BrkPtr );

       KbdCtrl	= (ADDRESS) KBDFLAG;
       keyboard_reset = 1;
	}

void gotoxy(x, y)
int x, y;
	{					/* gotoxy */
	REGS ir, or;
	ir.h.dh = y;
	ir.h.dl = x;
	ir.h.ah = 2;
	ir.h.bh = 0;
	int86(0x10, &ir, &or);
	}					/* gotoxy */
```

### K&R vs. ANSI C
STANPUMP is written in the now obsolete K&R style which was published in 1978 by Brian Kernighan and Dennis Ritchie.

This is mostly visible in the function prototypes, for example:

```C
void cube(k10,k12,k21,k13,k31,r)
double k10, k12, k21, k13, k31;
double *r;
	{					/* cube */
    /* function code */
	}					/* cube */
```

This is the modern ANSI C equivalent of this prototype:

```C
void cube(double k10, double k12, double k21, double k13, double k31, double *r);
```

### Memory allocations
Memory was very constrained on the systems on which STANPUMP was meant to run. No heap allocation is performed since this was unpredictable on MSDOS systems. Instead, all variables were statically allocated and all state was shared through global variables.

Global variable usage is frown upon nowadays because it makes it hard to reason about the state of the program and follow where the state was altered. It can also make the state unpredictable when multiple functions can alter it in different ways.

Some very smart design choices were made in STANPUMP to soften memory and CPU needs. It can be seen that the developers understood the algorithms deeply and precalculated certain values to be able to reuse them later.

One example is the introduction of "unit disposition functions" or UDFs.

```C
/* calculate udf, plasma concentration, for an infusion of 1/second */
p_udf[0] = 0;
for (i = 1;  i < 199;  i++)
	{
	temp1 = temp1 * l1 + p_coef[1] * (1 - l1);
	temp2 = temp2 * l2 + p_coef[2] * (1 - l2);
	temp3 = temp3 * l3 + p_coef[3] * (1 - l3);
	p_udf[i] = temp1 + temp2 + temp3;
	}
```

The UDFs serve as step response of the model and are calculated for plasma concentration and effect site concentration. They represent the response of the model for a contant infusion of 1 unit of drug per second. This needs to be calculated once and is kept in memory. This response vector can then later be scaled with the real infusion value.

### Calculation of Eigenvalues
STANPUMP uses closed form solutions of the PKPD differential functions in order be improve efficiency of calculations. These closed form solutions have been derived and published by the authors among others @shafer_algorithms_1992,@bailey_simple_1991.

In order to obtain these equations, the eigenvalues of the PKPD model need to be calculated. In the early 1990s, there were probably no mathematics libraries widely available to calculate eigenvalues, so the developers had to calculate them manually. This is done in the CUBE.C file.

First, the deteriminant of the system matrix is calculated and presented in the form of a depressed cubic equation: x^3 + px + q = 0.

Now, in the 1990s, there probably weren't any off the shelf solvers for cubic equations in C available either, so the authors used the trigonometric solutino by Girolamo Cardano from the 16th century to solve this equation and derive the eigenvalues. Trigonometric functions were part of the C standard library since 1978 and extended in 1989.

```C
void cube(k10,k12,k21,k13,k31,r)
double k10, k12, k21, k13, k31;
double *r;
	{					/* cube */
	double a0, a1, a2;	/* factors in cubic equation */
	double p, q;		/* factors in transformed equation */
	double phi;			/* used for root solving */
	double r1;			/* also used for root solving */
	double toradian;	/* mathematical conversion from degrees to radians */

	toradian = asin(1.0) * 2.0 / 180.0;	/* pi/180 */

	if (k31 > 0)
		{
	    /* first take roots of X^3 + a2X^2 + a1X^1 + a0 = 0 */
    	/* where the coefficients are : */
		a0 = k10 * k21 * k31;
		a1 = k10 * k31 + k21 * k31 + k21 * k13 + k10 * k21 + k31 * k12;
		a2 = k10 + k12 + k13 + k21 + k31;

	    /* now transform to x^3 + px + q = 0 */
		p = a1 - (a2 * a2 / 3.0);
		q = (2 * a2 * a2 * a2 / 27.0) - (a1 * a2 / 3.0) + a0;
		r1 = sqrt(-(p * p * p) / 27.0);
		phi = (-q / 2.0) / r1;
		if (phi > 1)
			phi = 1;
		else if (phi < -1)
			phi = -1;
		phi = (acos(phi) / 3.0);
		r1 = 2.0 * exp(log(r1) / 3.0);
		r[1] = -(cos(phi) * r1 - a2 / 3.0);
		r[2] = -(cos(phi + 120.0 * toradian) * r1 - a2 / 3.0);
		r[3] = -(cos(phi + 240.0 * toradian) * r1 - a2 / 3.0);
		}
	else
		{
		if (k21 > 0)
			{
		    /* first take roots of X^2 - a1X^1 + a0 = 0 */
    		/* where the coefficients are : */
			a0 = k10 * k21;
			a1 = -(k10 + k12 + k21);
			r[1] = (-a1 + sqrt(a1 * a1 - 4 * a0)) / 2;
			r[2] = (-a1 - sqrt(a1 * a1 - 4 * a0)) / 2;
			r[3] = 0;
			}
		else
			{
			/* one compartment model */
			r[1] = k10;
			r[2] = 0;
			r[3] = 0;
			}
		}

    /* sort - nothing fancy is needed */
	if (r[2] > r[1])
		swap(&r[2], &r[1]);
	if (r[3] > r[1])
		swap(&r[3], &r[1]);
	if (r[3] > r[2])
		swap(&r[3], &r[2]);
	}					/* cube */
```

### Core algorithm
In order tu study the algorithm, I extracted the core functions and their dependencies, converted them to ANSI C and implemented a minimal C program to run the algorithm.

The source code for this project can be found here: <https://framagit.org/jaj/ministan/-/tree/main/c>

I thought it was important to run the original STANPUMP code to serve as a reference implementation. Small errors can be easily introduced when an algorithm is re-implemented and small errors can be difficult to detect.

The reference implementation of STANPUMP can serve as a control to test if the output of our code is correct.

All global variables were moved into a struct named Config to serve as a state variable.

```C
/* cube.c */
void cube(double k10, double k12, double k21, double k13, double k31,
          double *r);

/* udfs.c */
void calculate_udfs(Config *cfg);

/* virtual_model.c */
double virtual_model(Config *cfg, double vm1, double vm2, double vm3,
                     double vm4, int t, int flag);

/* find_peak.c */
int find_peak(Config *cfg, int current_time, double rate, double temp1e,
              double temp2e, double temp3e, double temp4e);

/* model.c */
double model(Config *cfg, double temp1, double temp2, double temp3,
             double temp1e, double temp2e, double temp3e, double temp4e,
             double desired);
```

The cube() function was already discussed above. It calculates eigenvalues of the PK system which are widely used later in the code.

The calculate_udfs() function calculates the "unit disposition functions" (UDF). A 10 second infusion is simulated at constant (unit) rate. Then the model is run until the model is run without infusion to see when the concentration peaks (peak_time). The peak_time (also called time to peak effect TTPE) is a caracteristic of the model. It is used later in the model() function. The calculate_udfs() function also calculates the $c^p$ and $c^e$ coefficients.

The virtual_model() function runs the model without infusion rate for a specified time. This is useful to estimate where the concentrations are heading and to evaluate how rate needs to be adjusted.

find_peak() is a hill climbing algorithm to find out when concentration will peak given the current infusion rate.

The model() function is the main function of the algorithm. It orchestrates the other functions to find the optimal infusion rate for the given target.

## Reimplementation in Python
A lot of deep knowledge of TCI algorithms and programming skills went into STANPUMP. The authors derived part of the mathematics themselves to improve performance and used coding skills which made it possible to run the algorithms in real time on very rudementary hardware. The software has seen 10+ years of clinical usage and its algorithms are battle tested.

In order to experiment with the code and run it with my own models, I decided to reimplement the code in Python. First I did a (1:1 translation)[https://framagit.org/jaj/ministan/-/blob/main/python/ministan.py] of the C code and then I gradually replaced some parts with modern idioms such as array programming with NumPy @harris2020array.

For example, the calculation of the eigenvalues is straightforward with NumPy:
`
```{python}
#| eval: false
import numpy as np
A = [
    [-(k10 + k12 + k13), k21, k31],
    [k12, -k21, 0],
    [k13, 0, -k31],
]
lambdas = np.linalg.eigvals(A)
```

Probably some algorithms could be replaced by highly optimized functions from the SciPy library @2020SciPy-NMeth, such as the hill climbing algorithm in find_peaks(). There is still work to be done in this space.

The current version of the code can be found here: <https://framagit.org/jaj/ministan/-/blob/main/python/tci.py>

Here is an example code of a simulation of the Gepts Sufentanil model @gepts_linearity_1995:

https://framagit.org/jaj/ministan/-/blob/main/python/sim_gepts.py

The code calculates the rates for 3 different effect site targets and calculates the plasma and effect site concentrations obtained with the given rate. In addition to the closed form solutions, the code also calculates the results directly from the ODEs to validate the result using an independent calculation.

![](Figure_1.png)

The code could be coupled to a syringe pump control library such as InfuPy @joachim_jona_infupy_2021 to drive syringe pumps with the calculated rates. Of course this can only be used for research purposes and under no circumstances on real patients. See <https://www.demed.be/Rugloop%20&%20TCI%20news.htm#Background> for more information on this topic.


## Emulation


## References
::: {#refs}
:::
