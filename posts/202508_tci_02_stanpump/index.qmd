---
title: Deep dive into TCI - part 2 - STANPUMP
author: "Jona JOACHIM"
date: "2025-08-20"
categories: [pharmacometrics, tci]
bibliography: references.bib
csl: british-journal-of-anaesthesia.csl
---

The original source code for STANPUMP was written by Steven L. Shafer, one of the fathers of TCI. Steven Shafer wanted this software to be open source from the beginning which is a real gift for the community. Later, Charles Minto created the Open TCI website, which collects models and software related to PKPD and TCI. The latest version of STANPUMP is available here: [https://opentci.org/code/stanpump](https://opentci.org/code/stanpump).

## 16-bit real mode MSDOS
STANPUMP was written for the MSDOS operating system, running on x86 systems in "real mode". In real mode, program address physical memory directly with a maximum of 1 MB adressable memory. There is no memory protection and any memory location can be read and written by any program. The program interacts directly with the hardware through interrupts. This can for example be seen in the STANPUMP code which interacts with the keyboard or renders text on the screen.

```C
#define INT09	0x0009	    /* Keyboard interrupt number	       */
#define INT1B	0x001B	    /* Ctrl-C interrupt number		       */
#define INT23	0x0023	    /* Ctrl-Break interrupt number	       */

void set_keyboard()
	{
       OldInt09 = _dos_getvect( INT09 );
       OldInt1B = _dos_getvect( INT1B );
       OldInt23 = _dos_getvect( INT23 );

       KbdPtr = Int09;
       _dos_setvect( INT09, KbdPtr );

       BrkPtr = Int1B;
       _dos_setvect( INT1B, BrkPtr);

       BrkPtr = Int23;
       _dos_setvect( INT23, BrkPtr );

       KbdCtrl	= (ADDRESS) KBDFLAG;
       keyboard_reset = 1;
	}

void gotoxy(x, y)
int x, y;
	{					/* gotoxy */
	REGS ir, or;
	ir.h.dh = y;
	ir.h.dl = x;
	ir.h.ah = 2;
	ir.h.bh = 0;
	int86(0x10, &ir, &or);
	}					/* gotoxy */
```

## K&R vs. ANSI C
STANPUMP is written in the obsolete K&R style which was published in 1978 by Brian Kernighan and Dennis Ritchie.

This is mostly visible in the function prototypes, for example:

```C
void cube(k10,k12,k21,k13,k31,r)
double k10, k12, k21, k13, k31;
double *r;
	{					/* cube */
    /* function code */
	}					/* cube */
```

This is the modern ANSI C equivalent of this prototype:

```C
void cube(double k10, double k12, double k21, double k13, double k31, double *r);
```

## Memory allocations
Memory was very constrained on the systems on which STANPUMP was meant to run. No heap allocation is performed since this was unpredictable on MSDOS systems. Instead, all variables were statically allocated and all state was shared through global variables.

Global variable usage is frown upon nowadays because it makes it hard to reason about the state of the program and follow where the state was altered. It can also make the state unpredictable when multiple functions can alter it in different ways.

Some very smart design choices were made in STANPUMP to soften memory and CPU needs. It can be seen that the developers understood the algorithms deeply and precalculated certain values to be able to reuse them later.

One example is the introduction of "unit disposition functions" or UDFs.

```C
    /* calculate udf, plasma concentration, for an infusion of 1/second */
	p_udf[0] = 0;
	for (i = 1;  i < 199;  i++)
		{
		temp1 = temp1 * l1 + p_coef[1] * (1 - l1);
		temp2 = temp2 * l2 + p_coef[2] * (1 - l2);
		temp3 = temp3 * l3 + p_coef[3] * (1 - l3);
		p_udf[i] = temp1 + temp2 + temp3;
		}
```

The UDFs serve as step response of the model and are calculated for plasma concentration and effect site concentration. They represent the response of the model for a contant infusion of 1 unit of drug per second. This needs to be calculated once and is kept in memory. This response vector can then later be scaled with the real infusion value.

## Calculation of Eigenvalues
STANPUMP uses closed form solutions of the PKPD differential functions in order be improve efficiency of calculations. These closed form solutions have been derived and published by the authors among others @shafer_algorithms_1992,@bailey_simple_1991.

In order to obtain these equations, the eigenvalues of the PKPD model need to be calculated. In the early 1990s, there were probably no mathematics libraries widely available to calculate eigenvalues, so the developers had to calculate them manually. This is done in the CUBE.C file.

First, the deteriminant of the system matrix is calculated and presented in the form of a depressed cubic equation: x^3 + px + q = 0.

Now, in the 1990s, there probably weren't any off the shelf solvers for cubic equations in C available either, so the authors used the trigonometric solutino by Girolamo Cardano from the 16th century to solve this equation and derive the eigenvalues. Trigonometric functions were part of the C standard library since 1978 and extended in 1989.

```C
void cube(k10,k12,k21,k13,k31,r)
double k10, k12, k21, k13, k31;
double *r;
	{					/* cube */
	double a0, a1, a2;	/* factors in cubic equation */
	double p, q;		/* factors in transformed equation */
	double phi;			/* used for root solving */
	double r1;			/* also used for root solving */
	double toradian;	/* mathematical conversion from degrees to radians */

	toradian = asin(1.0) * 2.0 / 180.0;	/* pi/180 */

	if (k31 > 0)
		{
	    /* first take roots of X^3 + a2X^2 + a1X^1 + a0 = 0 */
    	/* where the coefficients are : */
		a0 = k10 * k21 * k31;
		a1 = k10 * k31 + k21 * k31 + k21 * k13 + k10 * k21 + k31 * k12;
		a2 = k10 + k12 + k13 + k21 + k31;

	    /* now transform to x^3 + px + q = 0 */
		p = a1 - (a2 * a2 / 3.0);
		q = (2 * a2 * a2 * a2 / 27.0) - (a1 * a2 / 3.0) + a0;
		r1 = sqrt(-(p * p * p) / 27.0);
		phi = (-q / 2.0) / r1;
		if (phi > 1)
			phi = 1;
		else if (phi < -1)
			phi = -1;
		phi = (acos(phi) / 3.0);
		r1 = 2.0 * exp(log(r1) / 3.0);
		r[1] = -(cos(phi) * r1 - a2 / 3.0);
		r[2] = -(cos(phi + 120.0 * toradian) * r1 - a2 / 3.0);
		r[3] = -(cos(phi + 240.0 * toradian) * r1 - a2 / 3.0);
		}
	else
		{
		if (k21 > 0)
			{
		    /* first take roots of X^2 - a1X^1 + a0 = 0 */
    		/* where the coefficients are : */
			a0 = k10 * k21;
			a1 = -(k10 + k12 + k21);
			r[1] = (-a1 + sqrt(a1 * a1 - 4 * a0)) / 2;
			r[2] = (-a1 - sqrt(a1 * a1 - 4 * a0)) / 2;
			r[3] = 0;
			}
		else
			{
			/* one compartment model */
			r[1] = k10;
			r[2] = 0;
			r[3] = 0;
			}
		}

    /* sort - nothing fancy is needed */
	if (r[2] > r[1])
		swap(&r[2], &r[1]);
	if (r[3] > r[1])
		swap(&r[3], &r[1]);
	if (r[3] > r[2])
		swap(&r[3], &r[2]);
	}					/* cube */
```

## Conclusion
A lot of deep knowledge of TCI algorithms and programming skills went into this software. The authors derived part of the mathematics themselves to improve performance and used coding skills which made it possible to run the algorithms in real time on very rudementary hardware.

## References
::: {#refs}
:::